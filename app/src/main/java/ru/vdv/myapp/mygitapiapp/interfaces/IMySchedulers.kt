package ru.vdv.myapp.mygitapiapp.interfaces

import io.reactivex.rxjava3.core.Scheduler

/**
 * Общий интерфейс внутреннего (собственного) планировщика
 *
 * Планируется реализация в цепочках RX для планирования выполнения конкретных задач
 * в конкретных потоках
 */

interface IMySchedulers {
    /**
     * работает на базе rxAndroid используется для выполнения задач в UI-потоке
     */
    fun main(): Scheduler

    /**
     * Этот тип планировщика планируется использовать для сетевых запросов, операций чтения данных из файла,
     * записи или чтения данных из БД. Такой планировщик создаёт необходимое
     * количество потоков для эффективного выполнения поставленной задачи, удаляет ненужные,
     * и старается переиспользовать потоки, которые могут понадобится.
     */
    fun io(): Scheduler

    /**
     * Этот вид планировщика планируется использовать для математичсеких вычислений.
     * Такой тип планировщика удобен тем, что создает количество потоков, соответствующее числу ядер
     * в процессоре для параллельной обработки. Ести есть сомнения какой использовать, лучше назначить
     * в качестве дефолтного. Многие операторы RxJava используют по умолчанию как раз Schedulers.computation()
     */
    fun computation(): Scheduler

    /**
     * Этот планировщик создаёт новый поток для каждого активного Observable, не переиспользуя старые..
     * в общем достаточно простой и понятный
     */
    fun newThread(): Scheduler

    /**
     * Этот планировщик планируется использовать, если необходимо выполнить всю работу последовательно
     * в одном потоке. Может быть полезен если необходимо выполнить потоконебезопасный код
     * в отдельном потоке.
     * (запланировано на самостоятельное изучение и опробование)
     */
    fun single(): Scheduler

    /**
     * Этот планировщик выполняет код в текущем потоке, используется для последовательного выполнения задач.
     */
    fun trampoline(): Scheduler

    /**
     * Метод инициализации планировщика
     */
    fun start()

    /**
     * Метод очистки планировщика (после очистки потребуется инициализировать планировщик заново)
     */
    fun shutdown()
}